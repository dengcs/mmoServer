---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dengcs.
--- DateTime: 2018/11/1 16:55
---
local mh_ceil 	= math.ceil
local tb_sort 	= table.sort
local tb_insert	= table.insert

local hide_byte_bit = 1024

local poker_type = {}

local function div4_ceil(val)
	return mh_ceil(val/4)
end

function poker_type.test_type(cards)
	local max_value, count = 0, 0, 0
	local len = #cards

	if len == 1 then
		max_value, count = poker_type.check_one(cards)
		if max_value > 0 then
			return POKER_TYPE_ONE, max_value, count
		end
	elseif len == 2 then
		max_value, count = poker_type.check_king(cards)
		if max_value > 0 then
			return POKER_TYPE_KING, max_value, count
		end

		max_value, count = poker_type.check_two(cards)
		if max_value > 0 then
			return POKER_TYPE_TWO, max_value, count
		end
	elseif len == 3 then
		max_value, count = poker_type.check_three(cards)
		if max_value > 0 then
			return POKER_TYPE_THREE, max_value, count
		end
	elseif len == 4 then
		max_value, count = poker_type.check_bomb(cards)
		if max_value > 0 then
			return POKER_TYPE_BOMB, max_value, count
		end

		max_value, count = poker_type.check_3with1(cards)
		if max_value > 0 then
			return POKER_TYPE_3WITH1, max_value, count
		end
	elseif len == 5 then
		max_value, count = poker_type.check_1straight(cards)
		if max_value > 0 then
			return POKER_TYPE_1STRAIGHT, max_value, count
		end

		max_value, count = poker_type.check_3with2(cards)
		if max_value > 0 then
			return POKER_TYPE_3WITH2, max_value, count
		end

		max_value, count = poker_type.check_4with1(cards)
		if max_value > 0 then
			return POKER_TYPE_4WITH1, max_value, count
		end
	else
		max_value, count = poker_type.check_1straight(cards)
		if max_value > 0 then
			return POKER_TYPE_1STRAIGHT, max_value, count
		end

		max_value, count = poker_type.check_2straight(cards)
		if max_value > 0 then
			return POKER_TYPE_2STRAIGHT, max_value, count
		end

		max_value, count = poker_type.check_3straight(cards)
		if max_value > 0 then
			return POKER_TYPE_3STRAIGHT, max_value, count
		end

		max_value, count = poker_type.check_3with1(cards)
		if max_value > 0 then
			return POKER_TYPE_3WITH1, max_value, count
		end

		max_value, count = poker_type.check_3with2(cards)
		if max_value > 0 then
			return POKER_TYPE_3WITH2, max_value, count
		end

		max_value, count = poker_type.check_4with1(cards)
		if max_value > 0 then
			return POKER_TYPE_4WITH1, max_value, count
		end

		max_value, count = poker_type.check_4with21(cards)
		if max_value > 0 then
			return POKER_TYPE_4WITH21, max_value, count
		end

		max_value, count = poker_type.check_4with22(cards)
		if max_value > 0 then
			return POKER_TYPE_4WITH22, max_value, count
		end
	end

end

-- 判断类型是否匹配
function poker_type.check_type(type, cards, value, count)
	local switch =
	{
		[POKER_TYPE_ONE] 		= poker_type.check_one,
		[POKER_TYPE_TWO] 		= poker_type.check_two,
		[POKER_TYPE_THREE] 		= poker_type.check_three,
		[POKER_TYPE_BOMB] 		= poker_type.check_bomb,
		[POKER_TYPE_1STRAIGHT] 	= poker_type.check_1straight,
		[POKER_TYPE_2STRAIGHT] 	= poker_type.check_2straight,
		[POKER_TYPE_3STRAIGHT] 	= poker_type.check_3straight,
		[POKER_TYPE_3WITH1] 	= poker_type.check_3with1,
		[POKER_TYPE_3WITH2] 	= poker_type.check_3with2,
		[POKER_TYPE_4WITH1] 	= poker_type.check_4with1,
		[POKER_TYPE_4WITH21] 	= poker_type.check_4with21,
		[POKER_TYPE_4WITH22] 	= poker_type.check_4with22,
	}

	local fn = switch[type]
	if fn then
		local max_value, ret_count = fn(cards)
		if max_value > value then
			if count then
				if count == ret_count then
					return type, max_value, count
				end
			else
				return type, max_value
			end
		end

		if type ~= POKER_TYPE_BOMB then
			max_value = poker_type.check_bomb(cards)
			if max_value > 0 then
				return POKER_TYPE_BOMB, max_value
			end
		end

		max_value = poker_type.check_king(cards)
		if max_value > 0 then
			return POKER_TYPE_KING, max_value
		end
	end
end

function poker_type.get_default_indexes(cards)
	local indexes = nil
	local max_value = 0

	local cards_len = 0
	for _, v in pairs(cards) do
		if v < hide_byte_bit then
			cards_len = cards_len + 1
		end
	end

	if cards_len == 2 then
		indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_KING, cards, 13)
		if indexes then
			return indexes, POKER_TYPE_KING, max_value
		end
	end

	if cards_len == 8 then
		indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_4WITH22, cards, 0)
		if indexes then
			return indexes, POKER_TYPE_4WITH22, max_value
		end
	end

	if cards_len == 6 then
		indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_4WITH21, cards, 0)
		if indexes then
			return indexes, POKER_TYPE_4WITH21, max_value
		end
	end

	if cards_len == 5 then
		indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_4WITH1, cards, 0)
		if indexes then
			return indexes, POKER_TYPE_4WITH1, max_value
		end
	end

	if cards_len == 4 then
		indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_BOMB, cards, 0)
		if indexes then
			return indexes, POKER_TYPE_BOMB, max_value
		end
	end

	indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_3WITH2, cards, 0, 1)
	if indexes then
		return indexes, POKER_TYPE_3WITH2, max_value, 1
	end

	indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_3WITH1, cards, 0, 1)
	if indexes then
		return indexes, POKER_TYPE_3WITH1, max_value, 1
	end

	indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_3STRAIGHT, cards, 1, 2)
	if indexes then
		return indexes, POKER_TYPE_3STRAIGHT, max_value, 2
	end

	indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_2STRAIGHT, cards, 2, 3)
	if indexes then
		return indexes, POKER_TYPE_2STRAIGHT, max_value, 3
	end

	indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_1STRAIGHT, cards, 4, 5)
	if indexes then
		return indexes, POKER_TYPE_1STRAIGHT, max_value, 5
	end

	indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_THREE, cards, 0)
	if indexes then
		return indexes, POKER_TYPE_THREE, max_value
	end

	indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_TWO, cards, 0)
	if indexes then
		return indexes, POKER_TYPE_TWO, max_value
	end

	indexes, max_value = poker_type.get_type_indexes(POKER_TYPE_ONE, cards, 0)
	if indexes then
		return indexes, POKER_TYPE_ONE, max_value
	end

	return indexes
end

function poker_type.get_type_indexes(type, cards, value, count)
	local switch =
	{
		[POKER_TYPE_ONE] 		= poker_type.get_one,
		[POKER_TYPE_TWO] 		= poker_type.get_two,
		[POKER_TYPE_THREE] 		= poker_type.get_three,
		[POKER_TYPE_BOMB] 		= poker_type.get_bomb,
		[POKER_TYPE_KING] 		= poker_type.get_two,
		[POKER_TYPE_1STRAIGHT] 	= poker_type.get_1straight,
		[POKER_TYPE_2STRAIGHT] 	= poker_type.get_2straight,
		[POKER_TYPE_3STRAIGHT] 	= poker_type.get_3straight,
		[POKER_TYPE_3WITH1] 	= poker_type.get_3with1,
		[POKER_TYPE_3WITH2] 	= poker_type.get_3with2,
		[POKER_TYPE_4WITH1] 	= poker_type.get_4with1,
		[POKER_TYPE_4WITH21] 	= poker_type.get_4with21,
		[POKER_TYPE_4WITH22] 	= poker_type.get_4with22,
	}

	local fn = switch[type]
	if fn then
		local mode = poker_type.get_cards_mode(cards)
		return fn(mode, value, count)
	end
end

function poker_type.get_cards_mode(cards)
	local mode = {}
	for i, v in pairs(cards or {}) do
		if v < hide_byte_bit then
			local card = div4_ceil(v)
			if not mode[card] then
				mode[card] = {}
			end
			tb_insert(mode[card], i)
		end
	end
	return mode
end

-- 检查牌型是否单张
function poker_type.check_one(cards)
	local len = #cards
	if len == 1 then
		return div4_ceil(cards[1])
	end
	return 0
end

-- 检查牌型是否对子
function poker_type.check_two(cards)
	local len = #cards
	if len == 2 then
		local king = 14
		local card1 = div4_ceil(cards[1])
		local card2 = div4_ceil(cards[2])
		if card1 == card2 and card1 < king then
			return card1
		end
	end
	return 0
end

-- 检查牌型是否3张
function poker_type.check_three(cards)
	local len = #cards
	if len == 3 then
		local card1 = div4_ceil(cards[1])
		local card2 = div4_ceil(cards[2])
		local card3 = div4_ceil(cards[3])
		if card1 == card2 and card2 == card3 then
			return card1
		end
	end
	return 0
end

-- 检查牌型是否炸弹
function poker_type.check_bomb(cards)
	local len = #cards
	if len == 4 then
		local card1 = div4_ceil(cards[1])
		local card2 = div4_ceil(cards[2])
		local card3 = div4_ceil(cards[3])
		local card4 = div4_ceil(cards[4])
		if card1 == card2 and card2 == card3 and card3 == card4 then
			return card1
		end
	end
	return 0
end

-- 检查牌型是否王炸
function poker_type.check_king(cards)
	local len = #cards
	if len == 2 then
		local king = 14
		local card1 = div4_ceil(cards[1])
		local card2 = div4_ceil(cards[2])
		if card1 == king and card2 == king then
			return card1
		end
	end
	return 0
end

-- 检查牌型是否顺子
function poker_type.check_1straight(cards)
	local len = #cards
	if len > 4 then
		tb_sort(cards)
		local first_card = div4_ceil(cards[1]) - 1
		local cur_card = 0
		for i, v in ipairs(cards) do
			cur_card = div4_ceil(v)
			if (first_card + i) ~= cur_card then
				return 0
			end
			-- 不包括2
			if cur_card >= GLOBAL_POKER_VALUE2 then
				return 0
			end
		end
		return cur_card, len
	end
	return 0
end

-- 检查牌型是否2连对
function poker_type.check_2straight(cards)
	local len = #cards
	if len > 5 then
		tb_sort(cards)
		local child_len = mh_ceil(len/2)
		-- 保证2的倍数
		if child_len*2 ~= len then
			return 0
		end

		local temp_card = div4_ceil(cards[1]) - 1
		for i = 1, child_len do
			local card1 = div4_ceil(cards[i*2 - 1])
			local card2 = div4_ceil(cards[i*2])
			if card1 ~= card2 then
				return 0
			end
			-- 保证连续
			if temp_card+i ~= card1 then
				return 0
			end
			-- 不包括2
			if card1 >= GLOBAL_POKER_VALUE2 then
				return 0
			end
		end
		return (temp_card + child_len), child_len
	end
	return 0
end

-- 检查牌型是否3连对
function poker_type.check_3straight(cards)
	local len = #cards
	if len > 5 then
		tb_sort(cards)
		local child_len = mh_ceil(len/3)
		-- 保证3的倍数
		if child_len*3 ~= len then
			return 0
		end

		local temp_card = div4_ceil(cards[1]) - 1
		for i = 1, child_len do
			local card1 = div4_ceil(cards[i*3 - 2])
			local card2 = div4_ceil(cards[i*3 - 1])
			local card3 = div4_ceil(cards[i*3])
			if card1 ~= card2 or card2 ~= card3 then
				return 0
			end
			-- 保证连续
			if temp_card+i ~= card1 then
				return 0
			end

			-- 不包括2
			if card1 >= GLOBAL_POKER_VALUE2 then
				return 0
			end
		end
		return (temp_card + child_len), child_len
	end
	return 0
end

-- 检查牌型是否3带1
function poker_type.check_3with1(cards)
	local len = #cards
	if len > 3 then
		local target_count = 0
		local temp_data = {}
		local check_cards = {}
		for _, v in pairs(cards) do
			local card = div4_ceil(v)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 3 and (len == 4 or card < GLOBAL_POKER_VALUE2) then
					target_count = target_count + 1
					tb_insert(check_cards, card)
				end
			end
		end

		-- 判断牌数对不对
		if target_count*4 ~= len then
			return 0
		end

		-- 判断连续
		tb_sort(check_cards)
		local first_card = check_cards[1] - 1
		local target_card = check_cards[target_count]

		if (target_card - first_card) == target_count then
			return target_card, target_count
		end
	end
	return 0
end

-- 检查牌型是否3带2
function poker_type.check_3with2(cards)
	local len = #cards
	if len > 4 then
		local target_count = 0
		local attach_count = 0
		local temp_data = {}
		local check_cards = {}
		for _, v in pairs(cards) do
			local card = div4_ceil(v)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 3  and (len == 5 or card < GLOBAL_POKER_VALUE2) then
					target_count = target_count + 1
					tb_insert(check_cards, card)
				elseif temp_data[card] == 2 then
					attach_count = attach_count + 1
				end
			end
		end

		-- 判断带的数量对不对
		if target_count*2 ~= attach_count then
			return 0
		end

		-- 判断牌数对不对
		if target_count*5 ~= len then
			return 0
		end

		-- 判断连续
		tb_sort(check_cards)
		local first_card = check_cards[1] - 1
		local target_card = check_cards[target_count]

		if (target_card - first_card) == target_count then
			return target_card, target_count
		end
	end
	return 0
end

-- 检查牌型是否4带1
function poker_type.check_4with1(cards)
	local len = #cards
	if len == 5 then
		local temp_data = {}
		for _, v in pairs(cards) do
			local card = div4_ceil(v)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 4 then
					return card
				end
			end
		end
	end
	return 0
end

-- 检查牌型是否4带2（带两单张）
function poker_type.check_4with21(cards)
	local len = #cards
	if len == 6 then
		local temp_data = {}
		for _, v in pairs(cards) do
			local card = div4_ceil(v)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 4 then
					return card
				end
			end
		end
	end
	return 0
end

-- 检查牌型是否4带2（带两对）
function poker_type.check_4with22(cards)
	local len = #cards
	if len == 8 then
		local target_card = 0
		local attach_count = 0
		local temp_data = {}
		for _, v in pairs(cards) do
			local card = div4_ceil(v)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 4 then
					target_card = card
				elseif temp_data[card] == 2 then
					attach_count = attach_count + 1
				end
			end
		end

		if target_card < 1 then
			return 0
		end

		if attach_count ~= 3 then
			return 0
		end

		return target_card
	end
	return 0
end

function poker_type.get_one(mode, value)
	local indexes = nil
	local max_value = 0
	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 1 then
			if i > value then
				indexes = v
				max_value = i
				break
			end
		end
	end
	return indexes, max_value
end

function poker_type.get_two(mode, value)
	local indexes = nil
	local max_value = 0
	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 2 then
			if i > value then
				indexes = v
				max_value = i
				break
			end
		end
	end
	return indexes, max_value
end

function poker_type.get_three(mode, value)
	local indexes = nil
	local max_value = 0
	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 3 then
			if i > value then
				indexes = v
				max_value = i
				break
			end
		end
	end
	return indexes, max_value
end

function poker_type.get_bomb(mode, value)
	local indexes = nil
	local max_value = 0
	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 4 then
			if i > value then
				indexes = v
				max_value = i
				break
			end
		end
	end
	return indexes, max_value
end

function poker_type.get_1straight(mode, value, count)
	local indexes = nil
	local max_value = 0

	if count < 5 then
		return
	end

	local key_list = {}

	for i, v in pairs(mode or {}) do
		local len = #v
		if len < 3 then
			tb_insert(key_list, i)
		end
	end

	local key_len = #key_list
	if key_len < count then
		return
	end

	tb_sort(key_list)

	local straight_count = 0
	local first = key_list[1] - 1
	for i, v in pairs(key_list) do
		if (first + i) == v then
			straight_count = straight_count + 1
		else
			straight_count = 1
			first = v - i
		end

		if straight_count >= count then
			if v > value then
				max_value = v
				break
			end
		end
	end

	if max_value > 0 and max_value < GLOBAL_POKER_VALUE2 then
		indexes = {}
		for i = count, 1, -1 do
			tb_insert(indexes, mode[max_value - i + 1][1])
		end
	end

	return indexes, max_value
end

function poker_type.get_2straight(mode, value, count)
	local indexes = nil
	local max_value = 0

	if count < 3 then
		return
	end

	local key_list = {}

	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 2 then
			tb_insert(key_list, i)
		end
	end

	local key_len = #key_list
	if key_len < count then
		return
	end

	tb_sort(key_list)

	local straight_count = 0
	local first = key_list[1] - 1
	for i, v in pairs(key_list) do
		if (first + i) == v then
			straight_count = straight_count + 1
		else
			straight_count = 1
			first = v - i
		end

		if straight_count >= count then
			if v > value then
				max_value = v
				break
			end
		end
	end

	if max_value > 0 and max_value < GLOBAL_POKER_VALUE2 then
		indexes = {}
		local card = 0
		for i = count, 1, -1 do
			card = max_value - i + 1
			tb_insert(indexes, mode[card][1])
			tb_insert(indexes, mode[card][2])
		end
	end

	return indexes, max_value
end

function poker_type.get_3straight(mode, value, count)
	local indexes = nil
	local max_value = 0

	if count < 2 then
		return
	end

	local key_list = {}

	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 3 then
			tb_insert(key_list, i)
		end
	end

	local key_len = #key_list
	if key_len < count then
		return
	end

	tb_sort(key_list)

	local straight_count = 0
	local first = key_list[1] - 1
	for i, v in pairs(key_list) do
		if (first + i) == v then
			straight_count = straight_count + 1
		else
			straight_count = 1
			first = v - i
		end

		if straight_count >= count then
			if v > value then
				max_value = v
				break
			end
		end
	end

	if max_value > 0 and max_value < GLOBAL_POKER_VALUE2 then
		indexes = {}
		local card = 0
		for i = count, 1, -1 do
			card = max_value - i + 1
			tb_insert(indexes, mode[card][1])
			tb_insert(indexes, mode[card][2])
			tb_insert(indexes, mode[card][3])
		end
	end

	return indexes, max_value
end

function poker_type.get_3with1(mode, value, count)
	local indexes = nil
	local max_value = 0

	if count < 1 then
		return
	end

	local attach_len = 0
	local first_keys = {}
	local key_list = {}

	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 3 then
			tb_insert(key_list, i)
		end

		if len == 1 then
			first_keys[i] = v[1]
			attach_len = attach_len + 1
		end
	end

	local key_len = #key_list
	if key_len < count then
		return
	end

	if attach_len < count then
		return
	end

	tb_sort(key_list)

	local straight_count = 0
	local first = key_list[1] - 1
	for i, v in pairs(key_list) do
		if (first + i) == v then
			straight_count = straight_count + 1
		else
			straight_count = 1
			first = v - i
		end

		if straight_count >= count then
			if v > value then
				max_value = v
				break
			end
		end
	end

	if max_value > 0 and (count == 1 or max_value < GLOBAL_POKER_VALUE2) then
		indexes = {}
		local card = 0
		for i = count, 1, -1 do
			card = max_value - i + 1
			tb_insert(indexes, mode[card][1])
			tb_insert(indexes, mode[card][2])
			tb_insert(indexes, mode[card][3])
		end

		local attach_count = 0
		for _, v in pairs(first_keys) do
			if attach_count < count then
				tb_insert(indexes, v)
				attach_count = attach_count + 1
			end
		end
	end

	return indexes, max_value
end

function poker_type.get_3with2(mode, value, count)
	local indexes = nil
	local max_value = 0

	if count < 1 then
		return
	end

	local attach_len = 0
	local first_keys = {}
	local key_list = {}

	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 3 then
			tb_insert(key_list, i)
		end

		if len == 2 then
			first_keys[i] = v
			attach_len = attach_len + 1
		end
	end

	local key_len = #key_list
	if key_len < count then
		return
	end

	if attach_len < count then
		return
	end

	tb_sort(key_list)

	local straight_count = 0
	local first = key_list[1] - 1
	for i, v in pairs(key_list) do
		if (first + i) == v then
			straight_count = straight_count + 1
		else
			straight_count = 1
			first = v - i
		end

		if straight_count >= count then
			if v > value then
				max_value = v
				break
			end
		end
	end

	if max_value > 0 and (count == 1 or max_value < GLOBAL_POKER_VALUE2) then
		indexes = {}
		local card = 0
		for i = count, 1, -1 do
			card = max_value - i + 1
			tb_insert(indexes, mode[card][1])
			tb_insert(indexes, mode[card][2])
			tb_insert(indexes, mode[card][3])
		end

		local attach_count = 0

		for i, v in pairs(first_keys) do
			if attach_count < count then
				tb_insert(indexes, v[1])
				tb_insert(indexes, v[2])
				attach_count = attach_count + 1
			end
		end
	end

	return indexes, max_value
end

function poker_type.get_4with1(mode, value)
	local indexes = nil
	local max_value = 0

	local attach_len = 0
	local first_val = nil
	local second_val = nil
	local key_list = {}

	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 4 then
			tb_insert(key_list, i)
		end

		if len == 1 then
			first_val = v[1]
			attach_len = attach_len + 1
		end

		if len == 2 then
			second_val = v[1]
			attach_len = attach_len + 1
		end
	end

	local key_len = #key_list
	if key_len < 1 then
		return
	end

	if attach_len < 1 then
		return
	end

	for _, v in pairs(key_list) do
		if v > value then
			max_value = v
			break
		end
	end

	if max_value > 0 then
		indexes = {}
		for _, v in pairs(mode[max_value] or {}) do
			tb_insert(indexes, v)
		end

		if first_val then
			tb_insert(indexes, first_val)
		elseif second_val then
			tb_insert(indexes, second_val)
		end
	end

	return indexes, max_value
end

function poker_type.get_4with21(mode, value)
	local indexes = nil
	local max_value = 0

	local attach_len = 0
	local first_val = nil
	local second_val = nil
	local key_list = {}

	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 4 then
			tb_insert(key_list, i)
		end

		if len == 1 then
			if not first_val then
				first_val = {}
			end
			tb_insert(first_val, v[1])

			attach_len = attach_len + 1
		end

		if len == 2 then
			if not second_val then
				second_val = {}
			end
			tb_insert(second_val, v[1])
			tb_insert(second_val, v[2])

			attach_len = attach_len + 2
		end
	end

	local key_len = #key_list
	if key_len < 1 then
		return
	end

	if attach_len < 2 then
		return
	end

	for _, v in pairs(key_list) do
		if v > value then
			max_value = v
			break
		end
	end

	if max_value > 0 then
		indexes = {}
		for _, v in pairs(mode[max_value] or {}) do
			tb_insert(indexes, v)
		end

		if first_val then
			local first_len = #first_val
			if first_len > 1 then
				tb_insert(indexes, first_val[1])
				tb_insert(indexes, first_val[2])
			else
				tb_insert(indexes, first_val[1])
				if second_val then
					tb_insert(indexes, second_val[1])
				end
			end
		elseif second_val then
			tb_insert(indexes, second_val[1])
			tb_insert(indexes, second_val[2])
		end
	end

	return indexes, max_value
end

function poker_type.get_4with22(mode, value)
	local indexes = nil
	local max_value = 0

	local attach_len = 0
	local first_val = nil
	local key_list = {}

	for i, v in pairs(mode or {}) do
		local len = #v
		if len == 4 then
			tb_insert(key_list, i)
		end

		if len == 2 then
			if not first_val then
				first_val = {}
			end
			tb_insert(first_val, v)

			attach_len = attach_len + 1
		end
	end

	local key_len = #key_list
	if key_len < 1 then
		return
	end

	if attach_len < 2 then
		return
	end

	for _, v in pairs(key_list) do
		if v > value then
			max_value = v
			break
		end
	end

	if max_value > 0 then
		indexes = {}
		for _, v in pairs(mode[max_value] or {}) do
			tb_insert(indexes, v)
		end

		if first_val then
			local first_len = #first_val
			if first_len > 1 then
				tb_insert(indexes, first_val[1][1])
				tb_insert(indexes, first_val[1][2])
				tb_insert(indexes, first_val[2][1])
				tb_insert(indexes, first_val[2][2])
			end
		end
	end

	return indexes, max_value
end

return poker_type