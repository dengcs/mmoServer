---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dengcs.
--- DateTime: 2018/11/5 17:06
---
local ENUM = require("config.enum")

local PLAY_STATE = ENUM.PLAY_STATE

local STATE_COUNT = {
	[PLAY_STATE.PREPARE] = 3,
	[PLAY_STATE.DEAL] = 3,
	[PLAY_STATE.SNATCH] = 5,
	[PLAY_STATE.PLAY] = 120,
}

local play_state = {}

function play_state.new()
	local manager = {}
	manager.play_core = {}

	setmetatable(manager, {__index = play_state})

	return manager
end

-- 接收玩法模块授权的函数
function play_state:copy_functions_from_core(functions)
	self.play_core.functions = assert(functions)
end

function play_state:call_super(fnName, ...)
	local func = self.play_core.functions[fnName]
	if func then
		return func(...)
	end
end

function play_state:reset_state_param()
	self.count  	= 1
	self.place_idx	= 0
end

function play_state:get_count()
	return self.count
end

function play_state:inc_count(count)
	local add_count = count or 1
	self.count 	= self.count + add_count
end

function play_state:inc_idx(count)
	local add_count = count or 1
	self.place_idx 	= self.place_idx + add_count
end

function play_state:start()
	self.state 	= PLAY_STATE.PREPARE
	self.count  	= 0
	self.place_idx	= 0
end

function play_state:stop()
	self.state 	= PLAY_STATE.OVER
	self:reset_state_param()
end

function play_state:watch_turn()
	return self.place_idx,self.state
end

function play_state:turn()
	self:turn_worker()
	return self.place_idx,self.state
end

function play_state:turn_worker()
	if self.state > PLAY_STATE.PLAY then
		return
	end

	local max_count = STATE_COUNT[self.state]
	self.count 	= self.count + 1

	if self.count > max_count then
		self.state = self.state + 1
		self:reset_state_param()
		self:monitor_event()
	end

	self.place_idx	= (self.place_idx % GLOBAL_PLAYER_NUM) + 1
end

function play_state:monitor_event()
	if self.state == PLAY_STATE.PLAY then
		self.place_idx = (self:call_super("get_landowner") or 0) - 1
		self:call_super("push_bottom")
	end
end

-- 运行到发牌
function play_state:run()
	repeat
		local place_idx, state = self:turn()
		self:call_super("state_notify", place_idx, state)
		if state > PLAY_STATE.DEAL then
			break
		end
	until(false)
end

function play_state:start_and_run()
	self:start()
	self:run()
end

function play_state:is_prepare()
	return self.state == PLAY_STATE.PREPARE
end

function play_state:is_snatch()
	return self.state == PLAY_STATE.SNATCH
end

function play_state:is_play()
	return self.state == PLAY_STATE.PLAY
end

function play_state:is_over()
	return self.state == PLAY_STATE.OVER
end

return play_state