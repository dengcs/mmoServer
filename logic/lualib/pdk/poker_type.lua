---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dengcs.
--- DateTime: 2018/11/1 16:55
---
local mh_ceil 	= math.ceil
local tb_sort 	= table.sort
local tb_insert	= table.insert

local poker_type = {}

-- 判断类型是否匹配
function poker_type.check_type(type, cards)
	local switch =
	{
		[POKER_TYPE_ONE] 		= poker_type.check_one,
		[POKER_TYPE_TWO] 		= poker_type.check_two,
		[POKER_TYPE_THREE] 		= poker_type.check_three,
		[POKER_TYPE_BOMB] 		= poker_type.check_bomb,
		[POKER_TYPE_KING] 		= poker_type.check_king,
		[POKER_TYPE_1STRAIGHT] 	= poker_type.check_1straight,
		[POKER_TYPE_2STRAIGHT] 	= poker_type.check_2straight,
		[POKER_TYPE_3STRAIGHT] 	= poker_type.check_3straight,
		[POKER_TYPE_3WITH1] 	= poker_type.check_3with1,
		[POKER_TYPE_3WITH2] 	= poker_type.check_3with2,
		[POKER_TYPE_4WITH1] 	= poker_type.check_4with1,
		[POKER_TYPE_4WITH21] 	= poker_type.check_4with21,
		[POKER_TYPE_4WITH22] 	= poker_type.check_4with22,
	}

	local fn = switch[type]
	if fn then
		return fn(cards)
	end

	return 0
end

-- 检测牌的类型
function poker_type.test_type(cards)
	local len = #cards

	if len == 1 then
		if poker_type.check_one(cards) > 0 then
			return POKER_TYPE_ONE
		end
	elseif len == 2 then
		if poker_type.check_king(cards) > 0 then
			return POKER_TYPE_KING
		elseif poker_type.check_two(cards) > 0 then
			return POKER_TYPE_TWO
		end
	elseif len ==3 then
		if poker_type.check_three(cards) > 0 then
			return POKER_TYPE_THREE
		end
	elseif len == 4 then
		if poker_type.check_bomb(cards) > 0 then
			return POKER_TYPE_BOMB
		elseif poker_type.check_3with1(cards) > 0 then
			return POKER_TYPE_3WITH1
		end
	elseif len > 4 then
		if poker_type.check_1straight(cards) > 0 then
			return POKER_TYPE_1STRAIGHT
		elseif poker_type.check_2straight(cards) > 0 then
			return POKER_TYPE_2STRAIGHT
		elseif poker_type.check_3straight(cards) > 0 then
			return POKER_TYPE_3STRAIGHT
		elseif poker_type.check_4with1(cards) > 0 then
			return POKER_TYPE_4WITH1
		elseif poker_type.check_4with21(cards) > 0 then
			return POKER_TYPE_4WITH21
		elseif poker_type.check_4with22(cards) > 0 then
			return POKER_TYPE_4WITH22
		elseif poker_type.check_3with1(cards) > 0 then
			return POKER_TYPE_3WITH1
		elseif poker_type.check_3with2(cards) > 0 then
			return POKER_TYPE_3WITH20
		end
	end

	return 0
end

-- 检测牌是否有效
function poker_type.check_valid(card)
	if card < 1 then
		return false
	end

	if card > GLOBAL_POKER_MAX then
		return false
	end
	return true
end

-- 检查牌型是否单张
function poker_type.check_one(cards)
	local len = #cards
	if len == 1 then
		return mh_ceil(cards[1]/4)
	end
	return 0
end

-- 检查牌型是否对子
function poker_type.check_two(cards)
	local len = #cards
	if len == 2 then
		local card1 = mh_ceil(cards[1]/4)
		local card2 = mh_ceil(cards[2]/4)
		if card1 == card2 then
			return card1
		end
	end
	return 0
end

-- 检查牌型是否3张
function poker_type.check_three(cards)
	local len = #cards
	if len == 3 then
		local card1 = mh_ceil(cards[1]/4)
		local card2 = mh_ceil(cards[2]/4)
		local card3 = mh_ceil(cards[3]/4)
		if card1 == card2 and card2 == card3 then
			return card1
		end
	end
	return 0
end

-- 检查牌型是否炸弹
function poker_type.check_bomb(cards)
	local len = #cards
	if len == 4 then
		local card1 = mh_ceil(cards[1]/4)
		local card2 = mh_ceil(cards[2]/4)
		local card3 = mh_ceil(cards[3]/4)
		local card4 = mh_ceil(cards[4]/4)
		if card1 == card2 and card2 == card3 and card3 == card4 then
			return card1
		end
	end
	return 0
end

-- 检查牌型是否王炸
function poker_type.check_king(cards)
	local len = #cards
	if len == 2 then
		local king = 13
		local card1 = mh_ceil(cards[1]/4)
		local card2 = mh_ceil(cards[2]/4)
		if card1 > king and card2 > king then
			return card1
		end
	end
	return 0
end

-- 检查牌型是否顺子
function poker_type.check_1straight(cards)
	local len = #cards
	if len > 4 then
		tb_sort(cards)
		local first_card = mh_ceil(cards[1]/4) - 1
		local cur_card = 0
		for i, v in ipairs(cards) do
			cur_card = mh_ceil(v/4)
			if (first_card + i) ~= cur_card then
				return 0
			end
		end
		return cur_card
	end
	return 0
end

-- 检查牌型是否2连对
function poker_type.check_2straight(cards)
	local len = #cards
	if len > 5 then
		tb_sort(cards)
		local child_len = mh_ceil(len/2)
		-- 保证2的倍数
		if child_len*2 ~= len then
			return 0
		end

		local temp_card = mh_ceil(cards[1]/4) - 1
		for i = 1, child_len do
			local card1 = mh_ceil(cards[i]/4)
			local card2 = mh_ceil(cards[i+1]/4)
			if card1 ~= card2 then
				return 0
			end
			-- 保证连续
			if temp_card+i ~= card1 then
				return 0
			end
		end
		return temp_card + child_len
	end
	return 0
end

-- 检查牌型是否3连对
function poker_type.check_3straight(cards)
	local len = #cards
	if len > 5 then
		tb_sort(cards)
		local child_len = mh_ceil(len/3)
		-- 保证3的倍数
		if child_len*3 ~= len then
			return 0
		end

		local temp_card = mh_ceil(cards[1]/4) - 1
		for i = 1, child_len do
			local card1 = mh_ceil(cards[i]/4)
			local card2 = mh_ceil(cards[i+1]/4)
			local card3 = mh_ceil(cards[i+2]/4)
			if card1 ~= card2 or card2 ~= card3 then
				return 0
			end
			-- 保证连续
			if temp_card+i ~= card1 then
				return 0
			end
		end
		return temp_card + child_len
	end
	return 0
end

-- 检查牌型是否3带1
function poker_type.check_3with1(cards)
	local len = #cards
	if len > 3 then
		local target_count = 0
		local temp_data = {}
		local check_cards = {}
		for _, v in pairs(cards) do
			local card = mh_ceil(v/4)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 3 then
					target_count = target_count + 1
					tb_insert(check_cards, card)
				end
			end
		end

		-- 判断牌数对不对
		if target_count*4 ~= len then
			return 0
		end

		-- 判断连续
		tb_sort(check_cards)
		local first_card = check_cards[1] - 1
		for i, v in pairs(check_cards) do
			if first_card + i ~= v then
				return 0
			end
		end
		return first_card + target_count
	end
	return 0
end

-- 检查牌型是否3带2
function poker_type.check_3with2(cards)
	local len = #cards
	if len > 4 then
		local target_count = 0
		local type_count = 0
		local temp_data = {}
		local check_cards = {}
		for _, v in pairs(cards) do
			local card = mh_ceil(v/4)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 3 then
					target_count = target_count + 1
					tb_insert(check_cards, card)
				elseif temp_data[card] == 2 then
					type_count = type_count + 1
				end
			end
		end

		-- 判断牌数对不对
		if target_count*5 ~= len then
			return 0
		end

		-- 判断带的数量对不对
		if target_count*2 ~= type_count then
			return 0
		end

		-- 判断连续
		tb_sort(check_cards)
		local first_card = check_cards[1] - 1
		for i, v in pairs(check_cards) do
			if first_card + i ~= v then
				return 0
			end
		end
		return first_card + target_count
	end
	return 0
end

-- 检查牌型是否4带1
function poker_type.check_4with1(cards)
	local len = #cards
	if len == 5 then
		local temp_data = {}
		for _, v in pairs(cards) do
			local card = mh_ceil(v/4)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 4 then
					return card
				end
			end
		end
	end
	return 0
end

-- 检查牌型是否4带2（带两单张）
function poker_type.check_4with21(cards)
	local len = #cards
	if len == 6 then
		local temp_data = {}
		for _, v in pairs(cards) do
			local card = mh_ceil(v/4)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 4 then
					return card
				end
			end
		end
	end
	return 0
end

-- 检查牌型是否4带2（带两对）
function poker_type.check_4with22(cards)
	local len = #cards
	if len == 8 then
		local target_card = 0
		local type_count = 0
		local temp_data = {}
		for _, v in pairs(cards) do
			local card = mh_ceil(v/4)
			if not temp_data[card] then
				temp_data[card] = 1
			else
				temp_data[card] = temp_data[card] + 1
				-- 收集重要数据
				if temp_data[card] == 4 then
					target_card = card
				elseif temp_data[card] == 2 then
					type_count = type_count + 1
				end
			end
		end

		if target_card < 1 then
			return 0
		end

		if type_count ~= 3 then
			return 0
		end

		return target_card
	end
	return 0
end

return poker_type