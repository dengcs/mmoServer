---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Dengcs.
--- DateTime: 2018/11/1 10:01
---
local random 	= require("utils.random")
local play_core	= require("pdk.play_core")

local tb_insert = table.insert

local play_manager = {}

function play_manager.new(channel)
	local manager = {channel = channel}
	manager.play_core = play_core.new()

	return setmetatable(manager, {__index = play_manager})
end

function play_manager:init()
	self.pokers 	= {} -- 洗的牌
	self.places 	= {} -- 每个座位上的牌
	self.bottoms 	= {} -- 底牌
	self.game		= {} -- 游戏相关信息

	for i = 1, GLOBAL_POKER_MAX do
		tb_insert(self.pokers, i)
	end

	for i = 1, GLOBAL_PLAYER_NUM do
		tb_insert(self.places, {cards = {}})
	end

	local functions = self:auth_functions_to_core()
	self.play_core:copy_functions_from_manager(functions)
end

-- 接收游戏模块授权的函数
function play_manager:copy_functions_from_game(functions)
	self.game.functions = assert(functions)
end

function play_manager:call_super(fnName, ...)
	local func = self.game.functions[fnName]
	if func then
		return func(...)
	end
end

function play_manager:auth_functions_to_core()
	local function broadcast(data)
		self:call_super("broadcast", data)
	end

	local function notify(idx, data)
		self:call_super("notify", idx, data)
	end

	local function event(id, data)
		self:call_super("event", id, data)
	end

	local function shuffle_and_deal()
		self:shuffle_and_deal()
	end

	local functions = {}
	functions.broadcast = broadcast
	functions.notify = notify
	functions.event = event
	functions.shuffle_and_deal = shuffle_and_deal

	return functions
end

-- 洗牌
function play_manager:shuffle()
	-- 1次随机洗牌
	local poker_max = GLOBAL_POKER_MAX
	local random_count = poker_max + random.Get(poker_max)
	local temp_poker = 0
	for i = 1, random_count do
		local random_idx = random.Get(poker_max)
		local cur_idx = (i % poker_max) + 1
		if random_idx ~= cur_idx then
			-- 随机交换牌
			temp_poker = self.pokers[cur_idx]
			self.pokers[cur_idx] 	= self.pokers[random_idx]
			self.pokers[random_idx] = temp_poker
		end
	end
end

-- 不洗牌
function play_manager:no_shuffle()
	local sequences 	= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}
	local sequence_len 	= #sequences
	-- 打乱顺序
	for i = 1, sequence_len do
		local random_idx = random.Get(sequence_len)
		if random_idx ~= i then
			local sequence = sequences[i]
			sequences[i] = sequences[random_idx]
			sequences[random_idx] = sequence
		end
	end
	-- 获取新牌
	-- 随机开始位置，防止切割固定牌
	local idx = random.Get(GLOBAL_POKER_MAX)
	local new_count = 3
	local new_pokers = table.clone(self.pokers)
	for i = 1, sequence_len do
		local sequence = sequences[i]
		for j = 1, new_count do
			local new_idx = sequence * new_count + j
			self.pokers[idx] = new_pokers[new_idx]
			idx = (idx % GLOBAL_POKER_MAX) + 1
		end
	end
end

-- 发牌
function play_manager:deal()
	local poker_idx = 1
	for _, v in pairs(self.places) do
		for i = 1, GLOBAL_POKER_NUM do
			v.cards[i] = self.pokers[poker_idx]
			poker_idx = poker_idx + 1
		end
	end

	-- 底牌
	for i = 1, 3 do
		self.bottoms[i] = self.pokers[poker_idx]
		poker_idx = poker_idx + 1
	end

	local core_data = {places = self.places, bottoms = self.bottoms}
	self.play_core:begin(core_data)
end

-- 洗牌并发牌
function play_manager:shuffle_and_deal()
	if self.channel > 2 then
		self:no_shuffle()
	else
		self:shuffle()
	end
	self:deal()
end

-- 玩家操作
function play_manager:update(idx, data)
	self.play_core:update(idx, data)
end

return play_manager