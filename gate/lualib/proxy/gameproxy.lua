---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dengcs.
--- DateTime: 2020/4/21 11:13
---
local skynet        = require "skynet"
local socketchannel = require "skynet.socketchannel"
local random        = require "utils.random"
local wshelper      = require "wshelper"

local str_pack          = string.pack
local str_unpack        = string.unpack
local tb_concat         = table.concat
local tb_insert         = table.insert
local sky_packstring    = skynet.packstring

local channels          = {}
local fd_channel_map    = {}

-- 回复消息
local function response(message)
    local fd	= message.header.fd
    local channel = fd_channel_map[fd]
    if channel then
        wshelper.write(fd, message)
    end
end

-- 客户端应答回调
local function dispatch_reply(so)
    local len_reply	= so:read(2)
    len_reply = str_unpack(">H", len_reply)
    local reply	= so:read(len_reply)
    local result = skynet.unpack(reply)

    if result and result.header and result.header.fd then
        skynet.error("dcs----response--", table.tostring(result))
        response(result)
    end

    return 0,true
end

local proxy = {}

function proxy.init()
    local config = require("config.proxy.center")
    for _,v in pairs(config or {}) do
        local channel = socketchannel.channel {
            host        = v.ip,
            port        = v.port,
            nodelay     = false,
            response    = dispatch_reply,
        }

        if channel then
            channel:connect(true)
            tb_insert(channels, channel)
        end
    end
end

-- 直接转发客户端数据
function proxy.forward(fd, msg)
    local channel = fd_channel_map[fd]
    if channel then
        if msg then
            skynet.error("dcs----request--", table.tostring(msg))
            local byte_fd = str_pack(">J", fd)
            local msg_data = sky_packstring(msg)
            local msg_len = str_pack(">H", msg_data:len() + byte_fd:len())
            local compose_data = {msg_len, byte_fd, msg_data}
            local packet_data = tb_concat(compose_data)

            channel:request(packet_data)
        end
    end
end

-- 客户端信号，需要自己构造协议头
function proxy.signal(fd, protoName)
    local channel = nil

    -- 缓存channel
    if protoName == "connect" then
        local channel_cnt = #channels
        if channel_cnt > 0 then
            local select = 1
            if channel_cnt > 1 then
                select = random.Get(channel_cnt)
            end
            channel = channels[select]
            fd_channel_map[fd] = channel
        end

    else
        channel = fd_channel_map[fd]
        fd_channel_map[fd] = nil
    end

    if channel then
        local msgData =
        {
            header =
            {
                proto   = protoName,
            }
        }
        local byte_fd = str_pack(">J", fd)
        local msg_data = sky_packstring(msgData)
        local msg_len = str_pack(">H", msg_data:len() + byte_fd:len())
        local compose_data = {msg_len, byte_fd, msg_data}
        local packet_data = tb_concat(compose_data)

        channel:request(packet_data)
    end
end

return proxy